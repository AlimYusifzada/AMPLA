import sys
import os.path
import warnings
from pathlib import Path
import threading as trd

amplahelp = '''
  Set of functions to compare AA/AAX and BA/BAX files
  generated by Online Builder (ONB) or Function Chart Builder (FCB)
  ONB and FCB are Asea Brown Bowery company products.
  (c) Copyright,2020 Alim Yusifzada

  importing sys; os.path; warnings; pathlib import Path; threading as trd
 '''

ampla_rev = ' 0.1.220724 '
if sys.version_info[0] < 3:
    warnings.warn('Please use Python version 3.*',stacklevel=0)
    sys.exit()

if __name__ == '__main__':
    print('\nAMPLA revision:'+ampla_rev)
    print(amplahelp)

NEQ = ' <- ! -> '
NEok = ' <- OK -> '
NEX = 'NOT EXIST'
NONE = 'NOT ASSIGNED'
RMVD = 'REMOVED'
NCD = 'NEW CODE'
TAB = 30
nSPC = -20


HEADER = ('design_ch', 'tech_ref', 'resp_dept', 'date',
          'l_text1', 'r_text1',
          'l_text2', 'r_text2',
          'l_text3', 'r_text3',
          'l_text4', 'r_text4',
          'rev_ind', 'language')

# ----------------------------------support functions--------------------------

def trimD(txt):
    '''
    remove D= and return only numbers as a string
    '''
    if txt[:2].upper() == 'D=':
        return txt[2:]
    return txt

def trimIO(txt):
    '''
    replace =DO. or =DI. with =
    '''
    vio=("=DO.","=DI.","=AI.","=AO.")
    vEQ="="
    for p in vio:
        txt=txt.upper().replace(p,vEQ)
    return txt

def isNum(txt):
    '''
    check if argument is a number
    '''
    try:
        float(trimD(txt))
        return True
    except:
        warnings.warn("cant read number @isNum(%s)"%txt,stacklevel=2)
        return False

def ziPins(pinAval, pinBval):
    '''
    compare two lists
    shortes append with NEX(not exist) values till they become equal length
    sort them and return as zip
    '''
    flag = False  # revert flag set if A/B values reverted
    # use to keep output A-first B-second
    if type(pinAval) != list and type(pinBval) != list:
        warnings.warn("incorrect type @ziPins(%s,%s)"%(type(pinAval),type(pinBval)),stacklevel=2)
        return None
    if type(pinAval) != list:
        pinAval = [pinAval, ]
    if type(pinBval) != list:
        pinBval = [pinBval, ]

    if max(len(pinAval), len(pinBval)) == len(pinAval):
        # select longest and shortest
        xList = pinAval  # longest
        mList = pinBval  # shortest
    else:
        xList = pinBval  # longest
        mList = pinAval  # shortest
        flag = True

    yList = []
    for rec in xList:
        if rec in mList:
            yList.append(rec)
        else:
            yList.append(NEX)
    for rec in mList:
        if rec not in xList:
            xList.append(NEX)
            yList.append(rec)
    if flag:
        return zip(yList, xList)
    else:
        return zip(xList, yList)

def readA(fName):
    '''
    read/unpack AA or BA file to Lines
    '''
    Lines = []
    tmpline = ''
    SPC = 0x80
    with open(fName, 'rb') as aafile:
        b = aafile.read(1)
        bip = 0x00  # hold previous bit int value
        while b:
            bi = int.from_bytes(b, 'big')  # convert byte to int
            if bi > SPC:  # check if it is compacted spaces
                # add spaces?
                nofSPC = bi-SPC  # calculate number of the spaces
                tmpline += ' '*nofSPC  # add spaces to the line
                pass
            if bi >= 0x20 and bi <= 0x7F and bip != 0x00:  # ASCII symbol, add as it is
                tmpline += b.decode()
                pass
            # if bi<0x20 and bip==0x00:
            #    pass
            if bi == 0x00 and bip > 0x00:
                # new line add
                # append self.Lines
                Lines.append(tmpline)
                tmpline = ''
                pass
            bip = bi
            b = aafile.read(1)
    return Lines

#------------------------------------------------------------Block class---------
class block:
    def __init__(self, address='', name='', extra=''):
        '''
        Constructor, create logic block instance, parent for dbinst
        Pins: contain logic block pins (dictionary keys) and values
        Name: logic block name: MOVE,OR,AND,..
        in case of BAX element used to keep instance type: DIC,AIC..
        Adress (unique): logic block address: PC12.1.1.2
        in case of BAX element used to keep instance name:
        Extra: the logic block parameters: MOVE(B,16)
        in case of BAX element can keep type of DAT: DAT4 (I)
        '''
        
        self.Pins = {}  # pins (keys) and connections {pin:connection,..}
        self.Name = name  # block NAME or Instance type if DB element
        self.Address = address  # PC##.##.##... or Instance name if DB element
        self.Extra = extra  # everything in the brackets no in use if DB element
        self.Description = ''
        self.LineNumber = 0  # line number at aax file.
        return

    def GetPin(self, pin)->str:
        '''
        Return string value of the pin
        block_obj.GetPin('pin')
        '''
        if pin in self.Pins.keys():
            return str(self.Pins[pin]) # pin could have several connections
        else:
            return NEX # Not EXisting pin

    def AddPin(self, pin, value):
        '''
        Create a pin with a value
        block_obj.AddPin('pin',pin_value)
        '''
        dPatn="D="
        hcFlag=False
        hcValue=.0

        if pin in self.Pins.keys():
            warnings.warn('pin %s already exist @AddPins' % pin,stacklevel=2)
            return False
        # analise the values and change if required.
        # hardcoded values MD,D,CD..
        if dPatn in value:# if dPatn in st get it's position
            dPos=value.index(dPatn)+2
            try:
                hcValue=float(value[dPos:])
                hcFlag=True
            except: hcFlag=False
        if hcFlag: self.Pins[pin]=str("D=%.6f"%hcValue)
        else: self.Pins[pin] = value
        return True

    def __str__(self)->str:
        '''
        Text representation of the Block
        print(block_obj) or str(block_obj)
        '''
        s = self.Address+'\t'+self.Name+self.Extra+'\t' + \
            self.Description+" line#"+str(self.LineNumber)+'\n'
        for k in self.Pins.keys():
            s += '\t'+str(k).ljust(TAB)+self.GetPin(k)+'\n'
        return s

    def __eq__(self, other)->bool:
        '''
        Compare blocks, return True or False
        block_obj1==block_obj2
        '''
        if isinstance(other, block):
            if other.Address == self.Address:
                if other.Name == self.Name:
                    if other.Extra == self.Extra:
                        if other.Pins == self.Pins:
                            if other.Description == self.Description:
                                return True
        return False

    def __add__(self, values):
        '''
        "Add new pin with values, first element is pin NAME
        rest of the elements added as list or tuple
        block_obj+=('pin',pin_value)
        block_obj=block_obj+('pin',pin_value)
        block_obj+=('pin',(pin_value1,pin_value2,..))
        '''
        if isinstance(values, tuple) or isinstance(values, list):
            if len(values) > 3:
                tmp = values[1:]
                self.AddPin(values[0], tmp)
            if len(values) == 2:
                self.AddPin(values[0], values[1])
        else:
            warnings.warn('function operand must be a list or a tuple @__add__',stacklevel=2)
        return self

    def __cmp(self, other)->str:
        '''
        Compare self to other logic block, return difference report
        (block_obj1.compare(block_obj2))
        '''
        flag = False  # used to switch comparision logic - if set difference found
        s = ''  # difference will be asembled here
        if isinstance(other, block):
            if self == other:
                return s
        sPinsList = list(self.Pins.keys())  # self Pins list
        oPinsList = list(other.Pins.keys()) # other Pins list

        if self.Name != other.Name:
            # Logic block names are different (replaced or moved)
            s += '\t'+' '*TAB + \
                self.Name.ljust(TAB)+NEQ+other.Name.rjust(TAB)+'\n'
            flag = True
            '''
            it is possible that logic block was replaced or moved
            old old block need to be deleted
            '''

        if self.Extra != other.Extra:
            # Configuartion parameters of the blocks are ifferent
            s += '\t'+' '*TAB + \
                self.Extra.ljust(TAB)+NEQ+other.Extra.rjust(TAB)+'\n'
            flag = True
            '''
            configuration paramenters changed
            it is possible that new change affect the parameters only
            if so the block need to be recreated
            '''

        if self.Description != other.Description:
            # Non critical difference in description found
            s += '\t'+' '*TAB + \
                self.Description.ljust(TAB)+NEok + \
                other.Description.rjust(TAB)+'\n'
            flag = True
            '''
            the description change and could be changed harmlessly
            '''

      # compare pins of the blocks
        for k in sPinsList:
            if k in oPinsList:
                # pin defined in both logic blocks
                if self.Pins[k] != other.Pins[k]:
                    # pin 'k' are not equal
                    flag = True
                    if isNum(self.Pins[k]) and isNum(other.Pins[k]):
                        if float(trimD(self.Pins[k])) == float(trimD(other.Pins[k])):
                            continue
                    zipns = ziPins(self.Pins[k], other.Pins[k])
                    stmp = str(self.Pins[k]).ljust(TAB) + \
                        NEQ+str(other.Pins[k]).rjust(TAB)+'\n'
                    if zipns != None:
                        stmp = ''
                        for z in zipns:
                            if z[0] != z[1]:
                                stmp += '\t'+' '*TAB+str(z[0]).ljust(TAB)+NEQ + \
                                    str(z[1]).rjust(TAB)+'\n'
                                '''
                                pin values dont match
                                '''
                            else:
                                stmp += '\t'+' '*TAB+str(z[0]).ljust(TAB)+NEok + \
                                    str(z[1]).rjust(TAB)+'\n'
                    s += '\t'+str(k).ljust(TAB)+stmp.lstrip()
                    '''
                    call function to add CF code
                    reconnect pins
                    '''

            else:  # pin is not in other block, probably the extra parameters changed
                if self.Pins[k] != NONE:
                    flag = True
                    s += '\t'+str(k).ljust(TAB) + \
                        str(self.Pins[k]).ljust(TAB) + \
                        NEQ+NEX.rjust(TAB)+'\n'
                    '''
                    call function to add CF code
                    recreate(replace) statement with new extra parameters
                    '''

        for k in oPinsList:
            if k not in sPinsList:
                if other.Pins[k] != NONE:
                    flag = True
                    s += '\t'+str(k).ljust(TAB) + \
                        NEX.ljust(TAB) + \
                        NEQ+str(other.Pins[k]).rjust(TAB) + '\n'
                    '''
                    call function to generate CF code
                    '''
        if flag:
            s = '\n'+self.Address+'\t'+self.Name+self.Extra+'\t' + \
                self.Description+" line#"+str(self.LineNumber)+'\n'+s
        return s
    compare = __cmp


#-------------------------------------------------AAX class-----------

class AAX:

    def __init__(self, fname):
        '''
        Constructor, create AAX file instance, parse AMPL logic
        Blocks: contains all logic blocks from AAX file
        fName: full path to AMPL aax file including file name
        Lines: text lines from AMPL file
        Header: AMPL code header
        Labels: all labels with addresses in the AMPL code
        '''
        self.PCName =''
        self.Blocks = {}  # logic elements (blocks)
        self.fName = fname  # aax file NAME
        self.Lines = []  # lines collection from aax file
        self.Header = {}  # aax header
        self.Labels = {}  # strore labels {"PC##.##.##":label}
        self.Read()
        self.Parse()
        self.difstat=False
        
    def Read(self):
        '''
        read AA/AAX/BA/BAX to buffer self.Lines
        '''
        try:
            self.Lines=[]
            lpath=self.fName
            while os.path.isfile(lpath):
                with open(lpath, 'r') as file:
                    llines=[] # temp list of lines (current file)
                    llines = file.readlines()  # read aax file to Lines
                '''
                check if the last line END PC##
                if yes we have done with reading the code
                if not search for the next file nnPCMMxx.AAX
                nn-Node number
                MM-PC number
                xx-file number 01, 02... (first file 01)
                '''
                self.Lines+=llines
                if "END" in self.Lines[-1]:
                    break #read everything and quit from while loop
                else:
                    file_num_pos=lpath.find(".AA")
                    if file_num_pos<0:
                        file_num_pos=lpath.find(".BA")
                        if file_num_pos<0:
                            #cant find file num
                            break
                    file_num=int(lpath[file_num_pos-2:file_num_pos])+1
                    lpath=lpath[:file_num_pos-2]+format(file_num,'#02')+lpath[file_num_pos:]
        except Exception as err:
            warnings.warn("error reading file: @Read(%s)\nerror:%s"%(self.fName,err),stacklevel=2)
            return

    def Write(self):
        try:
            with open(self.fName+'.txt', 'w') as file:
                for l in self.Lines:
                    file.write(l+'\n')
        except Exception as err:
            warnings.warn("error writing file: @Write(%s.txt)\nerror:%s" %(self.fName,err),stacklevel=2)

    def Parse(self):
        '''
        AMPL parsing
        '''
        par_pos = 0  # used for parsing
        linecounter = 0
        '''
        =0 ouside logic block
        =1 inside logic block
        =2 inside block the pin has several connections assignment 
        '''
        Address = ''  # address of the block
        BlockName = ''  # NAME of the block  or  pin
        PinName = ''
        Extra = ''
        PinValue = ''
        PinMulValues = []  # list of the values for multiple connected PINS
        ElementsCounter = 0  # number of elements in the line

        # AMPLE parsing logic from here
        for currentLine in self.Lines:
            linecounter += 1
            LineElements = currentLine.split()  # read line and split by spaces
            # count the elements in the line
            ElementsCounter = len(LineElements)
            if ElementsCounter > 0:
                # reading text from aax file header
                if LineElements[0].lower() in HEADER:
                    ss = ''
                    i = 0
                    for s in LineElements:
                        if i > 0:
                            ss = ss+s+' '
                        i += 1
                    self.Header[LineElements[0].lower()] = ss
                    continue

                # start of the logic block status=1 get address, name and params
                if LineElements[0][:2] == 'PC' and LineElements[0][2:3].isdigit() and par_pos != 2:
                    self.PCName=LineElements[0][0:3] #get PC name
                    Address = LineElements[0]  # get address
                    par_pos = 1  # block mark if position ==1 we are inside logic block
                    BlockName = ''
                    Extra = ''
                    if ElementsCounter > 1:
                        BlockName = LineElements[1]  # get blok NAME
                    if ElementsCounter > 2:
                        Extra = LineElements[2]  # get extra params
                    else:
                        if '(' in BlockName:  # no space between block name and extra
                            Extra = BlockName[BlockName.find('('):]
                            BlockName = BlockName[:BlockName.find('(')]
                    # create dbinstance block obj
                    self.Blocks[Address] = block(Address, BlockName, Extra)
                    self.Blocks[Address].LineNumber = linecounter
                    continue  # next line

                # inside block reading block name and other parts
                if par_pos == 1 and LineElements[0] == 'INAME':
                    if ElementsCounter > 1:
                        st = ''
                        for e in LineElements[1:]:
                            st += e
                        self.Blocks[Address].Description = st
                    continue  # go to the next line

                # inside block reading pins
                if par_pos == 1 and LineElements[0][:1] == ':':  # pin found
                    PinName = LineElements[0]  # get pin NAME
                    if ElementsCounter == 1:  # empty pin
                        PinValue = NONE
                        continue  # go to the next line
                    if ElementsCounter >= 2:  # if there are spaces in the pin value
                        st = ''
                        for e in LineElements[1:]:
                            st += e+''  # put all back in to one string
                        PinValue = trimIO(st)
                    if PinValue[-1:] == ',':  # another value at the next line
                        par_pos = 2  # pin values occupy several lines
                        PinMulValues.append(PinValue[:-1])
                        continue  # go to the next line
                    else:
                        self.Blocks[Address].AddPin(
                            PinName, PinValue)  # last value for the pin
                        par_pos = 1
                        continue  # go to the next line

                # pin has several values (multiple lines assignement)
                if par_pos == 2:  # one of the values for the pin - add it to the list

                    if ElementsCounter > 1:  # if there are spaces in the pin value
                        st = ''
                        for e in LineElements:
                            st += e+''  # put all back in to one string
                        PinValue = trimIO(st)
                    else:
                        PinValue = trimIO(LineElements[0])

                    if PinValue[-1:] == ',':  # there are still another value at the next line
                        PinMulValues.append(PinValue[:-1])
                    else:  # this is a last value for the pin
                        PinMulValues.append(PinValue)
                        PinMulValues.sort()
                        self.Blocks[Address].AddPin(
                            PinName, PinMulValues)  # add list to the pin
                        PinMulValues = []
                        par_pos = 1  # finish of multiple values reading

    def GetLabels(self)->dict:
        '''
        Populate dictionary 'self.Labels'
        with addresses and labels, then return it as result
        '''
        def getlabel(vx)->str:
            if vx[0:2] == 'N=':  # label found
                return str(addr)+str(pinname)
            else:
                warnings.warn("cant find label @getlabel",stacklevel=2)
                return ''

        for addr in self.Blocks:  # start for each logic block
            for pinname in self.Blocks[addr].Pins:  # for all PINS
                pinval = self.Blocks[addr].Pins[pinname]  # ger pin val
                if type(pinval) == list or type(pinval) == tuple:  # several connections
                    for val in pinval:
                        if type(val) == str:
                            if len(getlabel(val)) > 2:
                                self.Labels[getlabel(val)] = val[2:]
                elif type(pinval) == str:
                    if len(getlabel(pinval)) > 2:
                        self.Labels[getlabel(pinval)] = pinval[2:]
        return self.Labels

    def BlocksAround(self, key)->tuple:
        '''
        return tuple of the previous block and next block
        '''
        keys = tuple(self.Blocks.keys())
        key_ind = keys.index(key)
        if key_ind == 0:
            k1 = 0
            k2 = keys[key_ind+1]
        elif key_ind == len(keys)-1:
            k1 = keys[key_ind-1]
            k2 = 0
        else:
            k1 = keys[key_ind-1]
            k2 = keys[key_ind+1]
        return (k1, k2)

    def xRef(self, tag='dummy')->tuple:
        '''
        Cross referense search for the tag_name
        return tuple of addresses where it was found.
        Use cref(NONE) to search for unconnected pins
        To print all blocks out use as shown below
        for a in f.cref('tag_name'):
            print(f.Blocks[a[:a.index(':')]])
        '''
        out = ()
        for addr in self.Blocks:
            for pin in self.Blocks[addr].Pins:
                pinval = self.Blocks[addr].GetPin(pin)
                if tag in pinval:
                    out += (str(addr)+str(pin),)
        return out

    def GetBlock(self, blkey='')->block: # safely return block
        '''
        Return block by address
        dbinst=BAX_obj.getblock('DIC101')
        pcinst=AAX_obj.getblock('PC23.12.1.3')
        '''
        if blkey in self.Blocks.keys():
            return self.Blocks[blkey]
        else:
            warnings.warn("cant find block %s in Blocks @GetBlock"%blkey,stacklevel=2)
            return NONE

    def GetRevision(self)-> str:
        '''
        Return revision string or NEX
        '''
        k = 'rev_ind'
        if k in self.Header.keys():
            return self.Header[k].strip()
        else:
            return NEX

    def __cmp(self, other)->str:
        '''
        Compare AAX files and return text report
        print(AAX_obj1.compare(AAX_obj2))

        future version will have option to generate CF file
        '''
        self.difstat=False
        s = ''
        if isinstance(other, AAX):
            selfBlocks = self.Blocks.keys()
            otherBlocks = other.Blocks.keys()
            s += "\n HEADER INSPECTION\n"+'='*30
            if self.Header != other.Header:
                self.difstat=True
                for k in HEADER:
                    if k in other.Header and k in self.Header:
                        if self.Header[k] != other.Header[k]:
                            s += '\n\t'+str(k).ljust(TAB) + \
                                str(self.Header[k]).ljust(TAB)+NEok + \
                                str(other.Header[k]).rjust(TAB)
                '''
                Put warning to change header manually
                MDT command          
                '''
            s += "\n\n CODE INSPECTION\n"+'='*30
            if len(selfBlocks) != len(otherBlocks):
                self.difstat=True
                s += '\nnumber of logic blocks are different!\n \
                    at ..%s =%d\n \
                    at ..%s =%d\n' % \
                    (self.fName[nSPC:], len(self.Blocks.keys()),
                     other.fName[nSPC:], len(other.Blocks.keys()))
            for statement in self.Blocks.keys():
                if statement in other.Blocks.keys():
                    if self.Blocks[statement] != other.Blocks[statement]:
                        self.difstat=True
                        s += str(self.Blocks[statement].compare(other.Blocks[statement]))
                    if self.BlocksAround(statement) != other.BlocksAround(statement):
                        ksA, ksB = self.BlocksAround(statement)
                        koA, koB = other.BlocksAround(statement)
                        if ksA != koA and ksB != koB:
                            self.difstat=True
                            s += str("\nDANGLING CODE: %s\n" % statement)
                else:
                    # generate DS (Delete Statement ONB command)
                    self.difstat=True
                    s += '\n'+RMVD+' %s not found in AFTER but exist in BEFORE\n' %statement \
                        +str(self.Blocks[statement])
                    '''
                    call function to generate CF code
                    (delete statement DS)
                    '''
            for statement in other.Blocks.keys():
                if statement not in self.Blocks.keys():
                    # generate IS (Insert Statement ONB command)
                    self.difstat=True
                    s += '\n'+NCD+' %s not found in BEFORE but exist in AFTER\n' %statement \
                        +str(other.Blocks[statement])
                    '''
                    call function to generate CF code
                    (insert statement IS)
                    '''
        else:
            warnings.warn("type mismatch @__cmp(%s,%s)"%(type(self),type(other)),stacklevel=2)        
        return s
    compare = __cmp

#--------------------------------------------------BAX class----------

class BAX(AAX):

    def __init__(self, fname):
        '''
        Constructor, create BAX file instance, parse AMPL logic
        Blocks: contains all instances from BAX file
        fName: full path to AMPL bax file including file name
        Lines: text lines from AMPL file
        Header: AMPL code header
        Labels: all labels with addresses in the AMPL code
        '''
        super().__init__(fname)

    def Parse(self):
        Address = ''  # database instance unique value
        BlockName = ''  # type of the block  or  pin name
        PinName = ''
        # Extra = '' # not in use for BAX
        PinValue = ''
        # lpinval = []  # list of the values for multiple connected PINS
        ElementsCounter = 0  # number of elements in the line
        linecounter = 0

        # AMPLE parsing logic from here
        for currentLine in self.Lines:
            linecounter+=1
            lineWords = currentLine.split()  # read line and split by spaces
            ElementsCounter = len(lineWords)  # count the elements in the line
            if ElementsCounter > 0:
                # reading text from aax file header
                if lineWords[0].lower() in HEADER:
                    ss = ''
                    i = 0
                    for s in lineWords:
                        if i != 0:
                            ss = ss+s+' '
                        i += 1
                    self.Header[lineWords[0].lower()] = ss
                    continue
                # get address, name and params
                if lineWords[0][:1] != ':' and \
                        lineWords[0] != 'BEGIN' and lineWords[0] != 'END' and lineWords[0] != '(':
                    Address = lineWords[0]  # get address (Instance name)
                    if len(lineWords) >= 2:
                        BlockName = ''
                        for w in lineWords[1:]:
                            BlockName = BlockName+w
                    self.Blocks[Address] = block(
                        Address, BlockName, extra='')  # create logic block obj
                    self.Blocks[Address].LineNumber=linecounter
                    continue
                # read pins
                if lineWords[0][:1] == ':':  # start of the pin definition
                    PinName = lineWords[0]  # get pin NAME
                    if ElementsCounter >= 2:  # if there are spaces in the pin value
                        st = ''
                        for e in lineWords[1:]:
                            st += e+''  # put all back in to one string
                        PinValue = st
                    if ElementsCounter == 1:
                        PinValue = NONE  # empty pin
                    
                    if Address!='':
                        self.Blocks[Address].AddPin(
                            PinName, PinValue)  # last value for the pin

    def __cmp(self, other)->str:
        '''
        Compare BAX files and return text report
        '''
        s = ''
        if isinstance(other, BAX):
            skeys = self.Blocks.keys()
            okeys = other.Blocks.keys()
            s += "\n HEADER INSPECTION\n"+'='*30
            if self.Header != other.Header:
                for k in HEADER:
                    if k in other.Header and k in self.Header:
                        if self.Header[k] != other.Header[k]:
                            s += '\n\t'+str(k).ljust(TAB) + \
                                str(self.Header[k]).ljust(TAB)+NEok + \
                                str(other.Header[k]).rjust(TAB)
            s += "\n\n DATABASE INSPECTION\n"+'='*30
            if len(skeys) != len(okeys):
                s += '\nNumers of db instances are different\n \
                at ..%s =%d\n \
                at ..%s =%d\n' % \
                    (self.fName[nSPC:], len(self.Blocks.keys()),
                     other.fName[nSPC:], len(other.Blocks.keys()))
            for key in self.Blocks.keys():
                if key in other.Blocks.keys():
                    if self.Blocks[key] != other.Blocks[key]:
                        s += str(self.Blocks[key].compare(other.Blocks[key]))
                    if self.BlocksAround(key) != other.BlocksAround(key):
                        ksA, ksB = self.BlocksAround(key)
                        koA, koB = other.BlocksAround(key)
                        if ksA != koA and ksB != koB:
                            s += str("\nMisplaced db instance %s\n" % key)
                else:
                    # generate MDB command to spare the instance (do not delete)
                    # topup.bax
                    s += '\ninstance %s NOT FOUND at (AFTER)..%s but EXIST at (BEFORE)..%s\n' % \
                        (key, other.fName[nSPC:],
                         self.fName[nSPC:])+str(self.Blocks[key])
            for key in other.Blocks.keys():
                if key not in self.Blocks.keys():
                    # generate command to create new DB instance
                    s += '\ninstance %s NOT FOUND at (BEFORE)..%s but EXIST at (AFTER)..%s\n' % \
                        (key, self.fName[nSPC:],
                         other.fName[nSPC:])+str(other.Blocks[key])
        else:
            warnings.warn("type mismatch @__cmp(%s,%s)"%(type(self),type(other)),stacklevel=2)
        return s
    compare = __cmp

#----------------------------------------------------AA class----------
class AA(AAX):
    '''
    read (decode) AA file to self.Lines
    '''
    def __init__(self, fname):
        super().__init__(fname)

    def Read(self):
        try:
            self.Lines=[]
            lpath=self.fName
            while os.path.isfile(lpath):
                llines=[]
                llines= readA(lpath)
                # with open(lpath, 'r') as file:
                #     llines=[] # temp list of lines (current file)
                #     llines = file.readlines()  # read aax file to Lines
                '''
                check if the last line END PC##
                if yes we have done with reading the code
                if not search for the next file nnPCMMxx.AAX
                nn-Node number
                MM-PC number
                xx-file number 01, 02... (first file 01)
                '''
                self.Lines+=llines

                if "END" in self.Lines[-1]:
                    break #read everything and quit from while loop
                else:
                    file_num_pos=lpath.find(".AA")
                    if file_num_pos<0:
                        file_num_pos=lpath.find(".BA")
                        if file_num_pos<0:
                            #cant find file num
                            break
                    file_num=int(lpath[file_num_pos-2:file_num_pos])+1
                    lpath=lpath[:file_num_pos-2]+format(file_num,'#02')+lpath[file_num_pos:]
        except Exception as err:
            warnings.warn('error reading file %s @Read\nerror:%s'%(self.fName,err),stacklevel=2)
            return
        self.Parse()

#----------------------------------------------------BA class-----------
class BA(BAX):
    '''
    read BA files and parse using BAX class
    '''
    def __init__(self, fname):
        super().__init__(fname)

    def Read(self):
        try:
            self.Lines=[]
            lpath=self.fName
            while os.path.isfile(lpath):
                llines=[]
                llines= readA(lpath)
                # with open(lpath, 'r') as file:
                #     llines=[] # temp list of lines (current file)
                #     llines = file.readlines()  # read aax file to Lines
                '''
                check if the last line END PC##
                if yes we have done with reading the code
                if not search for the next file nnPCMMxx.AAX
                nn-Node number
                MM-PC number
                xx-file number 01, 02... (first file 01)
                '''
                self.Lines+=llines

                if "END" in self.Lines[-1]:
                    break #read everything and quit from while loop
                else:
                    file_num_pos=lpath.find(".AA")
                    if file_num_pos<0:
                        file_num_pos=lpath.find(".BA")
                        if file_num_pos<0:
                            #cant find file num
                            break
                    file_num=int(lpath[file_num_pos-2:file_num_pos])+1
                    lpath=lpath[:file_num_pos-2]+format(file_num,'#02')+lpath[file_num_pos:]
        except Exception as err:
            warnings.warn('error reading file %s @Read\nerror:%s'%(self.fName,err),stacklevel=2)
            return      
        self.Parse()


#--------------------------------------- support function-----------------
def LoadABXFile(fpath):
    ''' get path to the file and return AA AAX BA BAX object
        or None
    '''
    match fpath[-3:].upper():
        case '.AA':
            return AA(fpath)
        case '.AAX':
            return AAX(fpath)
        case '.BA':
            return BA(fpath)
        case '.BAX':
            return BAX(fpath)
    return None
    
def is_dbinst(val)->bool:
    '''
    if the value of the pin is DB instance
    '''
    if type(val) is str:
        if val[:1]=='=' or val[:2]=='-=':
            return True
    else:
        warnings.warn("incorrect type @is_dbinst",stacklevel=2)
    return False

def is_inverted(val)->bool:
    '''
    if the value is inverted
    '''
    if type(val) is str:
        if val[0]=='-':
            return True
    else:
        warnings.warn("incorrect type @is_inverted(%s)"%type(val),stacklevel=2)
    return False

def is_address(val)->bool:
    '''
    check if the val is an address (starts with PC..)
    '''
    if type(val) is str:
        if len(val)>=3:
            if val[:2]=='PC'or val[:3]=='-PC':
                return True
    else:
        warnings.warn("incorrect type @is_address(%s)"%type(val),stacklevel=2)
    return False

def is_pointer(val)->bool:
    '''
    check if the val is an address and pointing to a pin
    '''
    if type(val) is str:
        if is_address(val):
            if ':' in val:
                return True
    else:
        warnings.warn("incorrect type @is_pointer(%s)"%type(val),stacklevel=2)
    return False

def is_loop(blk,pin)->bool:
    '''
    check if the block has pin connected to itself
    '''
    if type(blk) is block and type(pin) is str:
        pval=get_pin_value(blk,pin)
        for v in pval:
            if is_address(v):
                if get_addr_pin(v)[0]==blk.Address:
                    return True
    else:
        warnings.warn("incorrect type @is_loop(%s,%s)"%(type(blk),type(pin)),stacklevel=2)
    return False

def get_PC_name_from_file(path)->str:
    '''
    return PC## based on the file name
    '''
    adrchk=is_address(path)
    if adrchk and path.find('.')>0:
        return str.removeprefix(path,'-')[:path.find('.')]
    elif adrchk:
        return str.removeprefix(path,'-')
    else:
        warnings.warn("incorrect type @GetPCName(%s)"%type(path))
    return path

def get_block_name(aax,path)->str:
    '''
    return block name at the path
    '''
    if (type(aax) is AAX or type(aax) is AA) and type(path) is str:
        if get_addr_pin(path)[0] in aax.Blocks:
            return aax.Blocks[get_addr_pin(path)[0]].Name
    else:
        warnings.warn("incorrect type @GetBlockName(%s,%s)"%(type(aax),type(path)))
    return ''

def get_block(aax,path)->block:
    '''
    return block by address or path from aax
    '''
    checked=type(aax) is AAX or type(aax) is AA
    if path[0]=='-': # dont need inversion.
        path=path[1:] 
    if checked and is_pointer(path):
        return aax.Blocks[get_addr_pin(path)[0]]
    if checked and is_address(path):
        return aax.Blocks[path]
    warnings.warn("incorrect type @GetBlock(%s,%s)"%(type(aax),type(path)))
    return None

def get_addr_pin(path)->tuple:
    '''
    return tuple (address, pin) // (str,str)
    '''
    if type(path) is str:
        if is_pointer(path):
            return (path[:path.find(':')],path[path.find(':'):])
        if is_address(path):
            return (path,)
    else:
        warnings.warn("incorrect type @GetAddrPin(%s)"%type(path))
    return ()

def get_pin_value(blk,pin)->tuple:
    '''
    return tuple or list of the <path> PC##.##.##:pin
    <aax> logic blocks container
    '''
    if type(blk) is block and type(pin) is str:
        if pin in blk.Pins:
            tp=type(blk.Pins[pin])
            if (tp is list) or (tp is tuple):
                return blk.Pins[pin]
            else:
                return (blk.Pins[pin],)
    else:
        warnings.warn("incorrect type @GetPinValue(%s,%s)"%(type(blk),type(pin)))
    return ()

#---------------------------------------Proj class------------------------
class Proj():

    def __init__(self,path) -> None:
        '''
        constructor
        '''
        self.SRCE={} # dict for PC programs pc program name is a key
        self.Read(path)
        pass
    
    def is_pc_exist(self,path)->bool:
        if is_address(path):
            pcn=get_PC_name_from_file(path)
            if pcn in self.SRCE.keys():
                if path in self.SRCE[pcn].Blocks.keys():
                    return True
        return False
    
    def Read(self,path):
        '''
        read all PC programs source code from the path
        and populate srlf.SRCE dictionary
        initiate parsing as different thread for each file
        '''
        dib=""
        self.SRCE.clear()
        if type(path) is not str:
            warnings.warn("incorrect type @ReadSRCE(%s)"%type(path),stacklevel=2)
            return

        def read_source(dib):
            bn=os.path.basename(dib)
            is_AAX=str(dib)[-2:].upper()=="AX"
            is_AA=str(dib)[-2:].upper()=="AA"
            srcfile=str(dib) #get the filename (full path)
            if is_AAX:
                pc=AAX(srcfile)
            elif is_AA:
                pc=AA(srcfile)
            else:
                warnings.warn("uncknown source @read_source(%s)"%dib,stacklevel=2)
                return
            pcnm=bn[:bn.index('.')][2:6]
            if pcnm[2]=='0': pcnm=pcnm.replace('0','')
            self.SRCE[pcnm]=pc
            
        try:
            for dib in Path(path).iterdir():
                if dib.is_file():
                    trd.Thread(target=read_source(dib)).start()
        except:
            warnings.warn("cant read file @read_source(%s)"%(dib),stacklevel=2)
        pass

    def Search(self,item)->tuple:
        '''
        search item between PC programs
        return tuple with addresses where item was found
        '''
        output=()
        if type(item) is str:
            for pc in self.SRCE:
                output=output+self.SRCE[pc].xRef(item)
        else:
            warnings.warn("incorrect type @SearchSRCE(%s)"%type(item),stacklevel=2)
        return output

# list of sink/source
Sources=[] # upstrean connections
Sinks=[] # downstream connections
Items=[] # database entries or other non-adress items
DeadSources=[] # untraceble sources, dead end
DeadSinks=[] # untraceble sinks, dead end

def is_input(blk,pin)->bool:
    '''
    check if pin is input
    need InputPins dictionary
    '''
    if type(blk) is block and type(pin) is str:
        if blk.Name in InputPins:
            for p in InputPins[blk.Name]:
                if p==pin:
                    return True
    else:
        warnings.warn("incorrect type @is_input(%s,%s)"%(type(blk),type(pin)),stacklevel=2)
    return False

def is_output(blk,pin)->bool:
    '''
    check if pin is output
    need OutputPins dictionary
    '''
    if type(blk) is block and type(pin) is str:
        if blk.Name in OutputPins:
            for p in OutputPins[blk.Name]:
                if p==pin:
                    return True
    else:
        warnings.warn("incorrect type @is_output(%s,%s)"%(type(blk),type(pin)),stacklevel=2)
    return False

def gen_pins(start=1,stop=2,mode='1')->tuple:
    '''
    generate series of pins names
    
    mode=1 gen pins in series between start and stop (1,2,3,...)
    
    mode=SW-C_in gen pins from 11 till stop
    in case stop = 30
    generate (11,12,21,22,31,32)

    mode=SW-C_out gen pins from 13 till stop+3 where stop is deciaml
    in case stop = 40
    generate (13,23,33,43)

    mode=SW_in
    generate inputs (11,21,31,41)

    mode=SW_out
    generate outputs (12,22,32,42)

    mode="CONV-IB_out"
    generate outputs (O1,O2,...Ox) s=stop

    mode="MUX-N_in"
    generate inputs A1..A19 IA1..IA19

    '''
    T=()
    if stop<=start:
        stop=start
        start=1
    match mode:
        case '1': 
            for i in range(start,stop+1):
                T=T+(':'+str(i),)
        case "SW-C_in": #SW-C inputs
            # pin in
            for i in range(1,int(stop+1)):
                T=T+(':'+str(i*10+1),':'+str(i*10+2))
        case "SW-C_out": #SW-C outputs
            for i in range(1,int(stop+1)):
                T=T+(':'+str(i*10+3),)
        case "SW_in":
            for i in range(1,int(stop+1)):
                T=T+(':'+str(i*10+1),)
        case "SW_out":
            for i in range(1,int(stop+1)):
                T=T+(":"+str(i*10+2),)
        case "CONV-IB_out":
            for i in range(1,int(stop+1)):
                T=T+(":O"+str(i),)
        case "MUX-N_in":
            for i in range(1,stop+1):
                sn=str(i)
                T=T+(":A"+sn,":IA"+sn,)
        case "MUXA-I":
            for i in range(1,stop+1):
                T=T+(":IA"+str(i),)
        case "CONV-BI_in":
            for i in range(1,stop+1):
                T=T+(":I"+str(i),)
        case "PB-DIAG_out":
            for i in range(1,stop+1):
                T=T+(":VALUE_"+str(i),)
        case "LIM-N":
            for i in range(1,stop+1):
                sn=str(i)
                T=T+(":A"+sn,":HLA"+sn,":LLA"+sn,)
        case "STEP":
            for i in range(1,stop+1):
                sn=str(i)
                T=T+(":JCOND"+sn,":JPOS"+sn,
                     ":RL"+str(i),":RH"+sn,":ACTTXT"+sn,":ACTSTA"+sn,
                     ":CONDTXT"+sn,":CONDSTA"+sn,":JTXT"+sn,)
        case "COMP-R_in":
            for i in range(1,stop+1):
                sn=str(i)
                T=T+(":H"+sn,":L"+str(sn))
        case "COMP-R_out":
            for i in range(1,stop+1):
                sn=str(i)
                T=T+(":I<H"+sn,":I>=H"+str(sn),":I>L"+str(sn),":I<=L"+str(sn))

    return T

def get_output_for(blk,pin)->tuple:
    '''
    return tuple of possible output pin(s)
    given pin should be input
    '''
    def getall():
        res=()
        for p in OutputPins[blk.Name]:
            res+=(blk.Address+p,)
        return res
    
    if type(blk) is not block or type(pin) is not str:
        warnings.warn("incorrect type @GetOutput(%s,%s)"%(type(blk),type(pin)))
        return ()
    if not is_input(blk,pin):
        warnings.warn("%s should be an input @GetOutput"%pin)
        return () # return empty tuple if pin is output
    #pin_int_num=int(pin[pin.find(':')+1:]) # get integer value of the pin
    match blk.Name:
        case "MOVE":
            return (blk.Address+':'+str(int(pin[pin.find(':')+1:])+20),)
        # blocks below have only one output pin
        case "SW-C":
            if pin==":ACT":
                return getall()
            else:
                return (blk.Address+':'+pin[1]+'3',)
        case _:
            return getall()

        # expand for other blocks
    # warnings.warn("block type:%s not found @GetOutput"%blk.Name)
    return ()

def get_input_for(blk,pin)->tuple:
    '''
    return tuple of possible input pin(s)
    given pin should be output pin
    '''
    def getall():
        res=()
        for p in InputPins[blk.Name]:
            res+=(blk.Address+p,)
        return res
    
    if type(blk) is not block or type(pin) is not str:
        warnings.warn("incorrect type @GetInput(%s,%s)"%(type(blk),type(pin)))
        return ()
    if not is_output(blk,pin):
        warnings.warn("%s should be an output @GetInput"%pin)
        return ()    
    match blk.Name:
        case "MOVE":
            return (blk.Address+':'+str(int(pin[pin.find(':')+1:])-20),)
        case "SW-C":
            return (blk.Address+':'+pin[1]+'1',blk.Address+':'+pin[1]+'2',blk.Address+':ACT',)
        case _:
            return getall()
    # warnings.warn("block type:%s not found @GetInput"%blk.Name)
    return ()

def get_sources(aax,sourcelst:list)->list:
    '''
    iterate trough the initial addresses list for the AAX(PC program)
    return list of sources
    '''
    # if type(aax) is not AAX or type(aax) is not AA:
    #     warnings.warn("incorrect type @ProcessSources(%s)"%type(aax))
    #     return
    deadsources=[] # name
    processed=[]
    def innerfunc(sources,srcadr):
        if is_inverted(srcadr):
            srcadr=srcadr[1:] # remove inversion
        if is_pointer(srcadr): # check if it is address with pin (pointer)
            blk=get_block(aax,srcadr) #get block object
            pin=get_addr_pin(srcadr)[1] #getpin name
            if is_loop(blk,pin): #if it's link to itself - just warn
                warnings.warn("loop detected @%s"%srcadr) 
            elif is_input(blk,pin): #check if the pin is input for the block
                for v in get_pin_value(blk,pin): #it should be only one value but...
                    if v[:2]=='D=' or isNum(v[:2]): # passing by hardcoded values
                        continue
                    sources.append(v)
            elif is_output(blk,pin):
                for v in get_input_for(blk,pin):
                    sources.append(v)
            else:
                if srcadr not in deadsources: #deadsources.keys()
                    if srcadr[:2]!='D=':
                        deadsources.append(srcadr)
        else:
            if srcadr not in deadsources: #check if it's already there
                if srcadr[:2]!='D=':
                    blk=get_block(aax,srcadr)
                    deadsources.append(srcadr) #add to the deads list
    
    while len(sourcelst)>0:
        src=sourcelst.pop(0) # get the first element
        if src not in processed:
            processed.append(src)
            trd.Thread(target=innerfunc(sourcelst,src),name=src)
    return deadsources
                   
def get_sinks(aax,sinklst:list)->list:
    '''
    iterate trough the Sink list
    multythreading!!!
    '''
    # if (type(aax) is not AAX) or (type(aax) is not AA):
    #     warnings.warn("incorrect type @ProcessSinks(%s)"%type(aax))
    #     return
    deadsinks=[]
    processed=[]
    def innerfunc(sinks,snkadr):
        if is_inverted(snkadr):
            snkadr=snkadr[1:] # remove invertion
        if is_pointer(snkadr): # check not database
            blk=get_block(aax,snkadr) # shell check if block exist?
            pin=get_addr_pin(snkadr)[1] # extract pin name
            if is_output(blk,pin): # check if the pin is output
                xrefpin=aax.xRef(snkadr) # search usage of the pin
                for v in xrefpin:
                    if not is_loop(blk,pin):
                        sinks.append(v) #add usage points to Sinks
                val=get_pin_value(blk,pin)
                for v in val:
                    if not is_loop(blk,pin):
                        sinks.append(v)
            elif is_input(blk,pin):
                for v in get_output_for(blk,pin):
                    if not is_loop(blk,pin):
                        sinks.append(v) # push at the end
            else:
                if snkadr not in deadsinks:
                    deadsinks.append(snkadr)  
        else:
            if snkadr not in deadsinks:
                deadsinks.append(snkadr)
   
    while len(sinklst)>0:
        snk=sinklst.pop(0)
        if snk not in processed:
            processed.append(snk)
            trd.Thread(target=innerfunc(sinklst,snk),name=snk)
    return deadsinks

def check_block_dict():
    
    for ky in InputPins.keys():
        if ky in OutputPins.keys():
            pass
        else:
            warnings.warn("%s\t/-> OutputPins"%ky)
   
    for ky in OutputPins.keys():
        if ky in InputPins.keys():
            pass
        else:
            warnings.warn("%s\t/-> InputPins"%ky)

def get_max(stat)->tuple:
    max=('dummy',0)
    for k in stat:
        if stat[k]>max[1]:
            max=(k,stat[k])
    return max

def get_sorted(stat)->tuple:
    res=()
    while len(stat)>0:
        i=get_max(stat)
        res+=(i,)
        stat.pop(i[0])
    return res

def get_stat(prj)->dict:
    '''
    statistical data
    logic blocks frequency
    '''
    stat={}
    for aax in prj.SRCE.keys():
        for blk in prj.SRCE[aax].Blocks.keys():
            blknme=get_block_name(prj.SRCE[aax],blk)
            if blknme in stat.keys():
                stat[blknme]+=1
            else:
                stat[blknme]=1
    return stat

'''
dictionary of BLOCKs and PINs, 
even single pin elemets should be stored as a tuple!
'''
InputPins={
    "BLOCK":(":ON",":1"),
    "MUL":gen_pins(1,19),
    "MOVE":gen_pins(1,19),
    "MOVE-A":gen_pins(1,19),
    "AND":gen_pins(1,19),
    "OR":gen_pins(1,19),
    "SUB":(":1",":2"),
    "DIV":(":1",":2"),
    "OR-A":gen_pins(1,59),
    "ABS":(":1",":2",":I",":K"),
    "ADD-MR":gen_pins(1,49),
    "ADD-MR1":gen_pins(1,94),
    "ANALYSE":(":1",":2",":11",":21",":31",":MPLDH1",":HYS",":CLDH1",":CLDH2",":CLDH3"),
    "COM-AIS":(":1",":2",":3",":4",":5",":6",":21",":23",":24"),
    "ADD":gen_pins(1,19),
    "AND-O": gen_pins(1,59),
    "SW":(":ACT",":1")+gen_pins(9,mode="SW_in"),#calculate
    "SW-C":(":ACT",":1")+gen_pins(9,mode="SW-C_in"),#calculate
    "COMP":(":I1",":I2",":1",":2"),
    "COMP-I":(":I1",":I2",":1",":2"),
    "CONTRM":(":ON",":1",":SINGLE",":2",":R",":3"),
    "CONV":(":I",":1"),
    "CONV-AI":(":1",":BA_1",":2","::BA_2",":3","::BA_3",":4","::BA_4"),
    "TON":(":I",":TD",":1",":2"),
    "TOFF":(":I",":TD",":1",":2"),
    "COUNT":(":L",":U/D-N",":C",":R",":EN",":21",":I")+gen_pins(1,5),
    "CONV-IB":(":S",":L",":R",":I",":1",":2",":3",":10"),
    "MONO":(":RTG",":I",":TP",":1",":2",":3"),
    "TRIGG":(":1",),
    "TON-RET":(":1",":2",":3",":I",":R",":TD"),
    "DATE":(),
    "TIME":(),
    "MUX-N":gen_pins(19,mode="MUX-N_in"),
    "SENDREQ":(":ACT",":NODE",":NET",":IDENT",":DEST_NET",":DEST_NODE",":BLOCK",":PRVBLK"),
    "OSC-B":(":EN",":TP",":TC",":1",":2",":3"),
    "CONV-BI":(":S",":L",":R",":SIGN")+gen_pins(32,mode="CONV-BI_in"),
    "PB-DIAG":(":DBINST",":VALUENO"),
    "COUNT-L":(":L",":U/D-N",":C",":R",":EN",":HL",":LL",":I"),
    "INT":(":I",":K",":TI",":RINT",":BAL",":BALREF")+gen_pins(stop=6),
    "TIMER":(":YEAR1",":WEEK1",":DAY1",":TON1",":TOFF1",
             ":YEAR2",":WEEK2",":DAY2",":TON2",":TOFF2")+gen_pins(start=11,stop=15)+gen_pins(start=21,stop=25),
    "DIV-MR": gen_pins(stop=39),
    "VALVECON": (":PARAM",":FLT1",":FLT2",":IC1",":IC2",":IB1",":IB2",":IB3",":IB4",
                 ":IBF",":IA",":T1",":T2",":FINV",":OPEN",":CLOSE",
                 ":TOPN",":TCLS",":LSOPN",":LSCLS",":LSMEM",":LE",":LOPN",":LCLS",
                 ":MAN",":AUTO",":AOPN",":ACLS"),
    "STEP":(":STEPNO",":COND",":ALEN",":ALTD",":ALLACT",":STEPTO",":STEPNAME",":LOAD_DB",":52",":INFTXT",":BLANKINF",":VALUE")+gen_pins(stop=8,mode="STEP"),
    "SEQ":(":START",":STARTC",":R",":MAN",":UNCOND",":STEP",":JUMP",":HOLD",":ALEN",":ALTD",":DBINST"),
    "EVENT":(":EN",":TERM",":MV800",":BELL",":BLINK",":INVERSE",":DIALOG",":FIRST",":PROC_SEC",":NET",
             ":NIDE",":EV_TR",":TIME_TAG",":UNC_TIME",
             ":ACT1",":T1_1",":T2_1",":T3_1"),
    "MOTCON":(":PARAM",":ME",":M1",":M2",":M3",":M4",":IC1",":IC2",":IB1",":IB2",":IB3",":IB4",":IBF",":IA",
              ":T1",":T2",":T3",":STF",":START",":STOP",":ACK1",":ACK2",":T4",":TST1",":TST2",":TSTF",
              ":LE",":L1",":L2",":L0",":MAN",":AUTO",":A1",":A2",":A0",
              ":V1",":V2",":V2F",":X1",":X2",":ALENX1",":ALENX2"),
    "XOR":(":1",":2"),
    "SR-AA": gen_pins(stop=19),
    "SR-OO": gen_pins(stop=19),
    "SR-AO": gen_pins(stop=19),
    "SR":(":S",":R"),
    "RAMP":(":I",":STEP+",":STEP-",":SLOPE+",":SLOPE-",":BAL",":BALREF",":OHL",":OLL"),
    "LIM-N":(":I",)+gen_pins(stop=9,mode="LIM-N"),
    "INV":(":1",),
    "MUXA-I":(":A",)+gen_pins(stop=19,mode="MUXA-I"),
    "THRESH-L":gen_pins(stop=19),
    "FUNG-1V":(":X",":BAL",":BALREF",":XTAB",":YTAB"),
    "REG-G":(":S",":L",":WR",":AWR",":R",":EXP",)+gen_pins(stop=30,mode="CONV-BI_in"),
    "PIDCON":(":TRACKA",":TRACKB",":TRACKC",":REVACT",":DERIV",":HOTINIT",":PARAM1",":PARAM2",":PARAM3A",":MV",
              ":SPEED1",":SPEED4",":MANENBL",":AUTOENBL",":DBINST",
              ":E1ENBL",":E2ENBL",":E3ENBL",
              ":EXTREF1",":EXREF2",":EXTREF3",
              ":SPEED2",":SPEED3",":E1FL",":E2FL",":E3FL",":SEQE1",":SEQE2",":SEQE3",
              ":LOCALF",":LOCAL",":BALIN",":MANFL",":AUTOFL",":SEQMAN",":SEQAUTO",":BALREF",
              ":PARAM7",":ALCBLK",":CLAMP",":CLAMPREF",":EOLIM",":EOLL",":EOHL",
              ":EGAINE",":GAIN",":ETIE",":TI",":ETDE",":TD",":ETFE",":TF",":EINTBE",
              ":EINTBLK",":EDERBE",":EDERBLK"),
    "COMP-R":(":I",":HHYS",":LHYS")+gen_pins(stop=9,mode='COMP-R_in'),
    "REG-RET":(":S",":L",":R")+\
        gen_pins(start=11,stop=19)+\
        gen_pins(start=21,stop=29)+\
        gen_pins(start=31,stop=39)+\
        gen_pins(start=41,stop=49)+\
        gen_pins(start=51,stop=59),
    "MUX-I":(":A",)+gen_pins(stop=19,mode="MUXA-I"),
    "MUX-MN":(":S",":L",":R")+gen_pins(stop=19,mode='MUX-N_in'),
    "GENUSD-I":(":DBINST",":M1",":M2",":M3",":MAN",":AUTO",":BLK",":STBY",
                ":ALQ1",":ALQ2",":ALF1",":ALF2",":ALF3",":ALF4",":ALF5",":ALF6",
                ":INTLU1",":INTLU2",":INTLU3",":INTLU4",":INTLU5",":INTLU6",
                ":IND1",":IND2",":IND3",":IND4"),
    "GENUSD-O":(":ORDERS",),
    "MIN":(":DEADB",)+gen_pins(stop=19,mode='MUXA-I'),
    "MAX":(":DEADB",)+gen_pins(stop=19,mode='MUXA-I'),
    "REG":(":S",":L",":R")+gen_pins(stop=35,mode="CONV-BI_in"),
    # FUNCM
    # PCPGM
	# MMC-IND
	# MMC-ORD
	# BTST
	# CE-MATR
	# SHIFT-L
	# SR-OA
	# EXP
	# LN
	# DP820-I
}

# dictionary of tuples!, even single elemets should be stored as tuple
OutputPins={
    "BLOCK":(":RUN",":5"),
    "MUL":(":20",),
    "SUB":(":20",),
    "DIV":(":20",),
    "MOVE":gen_pins(21,39),
    "MOVE-A":gen_pins(21,39),
    "AND":(":20",),
    "OR":(":20",),
    "ADD":(":20",),
    "ABS":(":5",":O"),
    "ADD-MR":(":50",),
    "ADD-MR1":(":95",),
    "AND-O":(":60",),
    "OR-A":(":60",),
    "ANALYSE":(":5",":6",":7",":8",":12",":22",":32",":MPLD",":OVERLD",":MPLD>H1",":CLD",":CLD>H1",":CLD>H2",":CLD>H3"),
    "COM-AIS":(":7",":8",":9",":10",":11",":22",":25",":33",":36"),
    "MONO":(":O",":TE",":5",":6"),
    "SW":gen_pins(9,mode="SW_out"),#calculate
    "SW-C":gen_pins(9,mode="SW-C_out"),#calculate
    "COMP":(":I1>I2",":I1=I2",":I1<I2",":5",":6",":7"),
    "COMP-I":(":I1>I2",":I1=I2",":I1<I2",":5",":6",":7"),
    "CONTRM":(":RUN",":5",":MODP",":6"),
    "CONV":(":O",":ERR",":5",":6"),
    "CONV-AI":(":O",":5"),
    "TON":(":O",":5",":TE",":6"),
    "TOFF":(":O",":5",":TE",":6"),
    "COUNT":(":>0",":=0",":<0",":O",":10",":11",":12",":22"),
    "CONV-IB":(":ERR",":SIGN",":ZERO")+gen_pins(32,mode="CONV-IB_out"),
    "TRIGG":(":5",),
    "TON-RET":(":5",":6",":O",":TE"),
    "DATE":(":5",":6",":7",":YEAR",":MONTH",":DAY"),
    "TIME":(":5",":TIME"),
    "MUX-N":(":O",":AERR"),
    "SENDREQ":(":BUSY",":DEST_ERR",":NXTBLK"),
    "OSC-B":(":O",":5"),
    "CONV-BI":(":ERR",":5",":O",":50"),
    "PB-DIAG":(":VALID",":ERR",":ERRTYPE")+gen_pins(32,mode="PB-DIAG_out"),
    "COUNT-L":(":>0",":=0",":<0",":>=HL",":<=LL",":O"),
    "INT":(":OHL",":OLL",":O",":O=HL",":O=LL",":ERR")+gen_pins(start=7,stop=13),
    "TIMER":(":O1",":O2",":16",":26"),
    "DIV-MR":(":40",),
    "VALVECON": (":RESULT",":RMORD",":NOINT",":TEST",":BLK",":IPOS",
                 ":RDY",":OPN",":OPNP",":OPNL",":CLS",":CLSP",":CLSL",
                 ":SEQ",":LOC",":INDM",":INDA"),
    "STEP":(":RUN",":AL",":ALTE",":STEPSTAT",":INFVAL"),
    "SEQ":(":RUN",":MODE",":POS",":END",":NEXT",":NEXTSTEP",":SEQAL",":SEQTE",":STEPAL",":SEQTD",
           ":STEPTD",":STEPTE",":AUTOM",":MANM",":HOLDM",":UNCONDM",":JPOSO",":SEQIND",":SEQVAL",":FAULT",":UNACK-N"),
    "EVENT":(":ERR",":BUSY",":NODE_ERR"),
    "MOTCON":(":RESULT",":RMORD",":NOINT",":TRIP",":BLK",":RFS",":SO1",":SACK",":RUN",":SEQ",":SO2",":DCH",":LOC",":INDM",":INDA",":Y1",":Y2",":Y3"),
    "XOR":(":5",),
    "SR-AA":(":20",),
    "SR-AO":(":20",),
    "SR-OO":(":20",),
    "SR":(":5",),
    "RAMP":(":O",":O=HL",":O=LL",":ERR"),
    "LIM-N":(":AERR",":ERR",":O",":I>HLA",":HLA",":I<LLA",":LLA"),
    "INV":(":5",),
    "MUXA-I":(":AERR",":O"),
    "THRESH-L":(":20",),
    "FUNG-1V":(":Y",":ERR",":BALREFO"),
    "REG-G":(":AERR",":O"),
    "PIDCON":(":PARAM4",":PARAM5",":PARAM6",":AUTOSP",":WSP",":DEV",":OUTP",":BAL",":MAN",":AUTO",":OUT=LL",":OUT=HL",":PARAM3B",
              ":E1",":E2",":E3",":BALOUT",":SP=LL",":SP=HL",":MV_LT_L2",":MV_LT_L1",":MV_GT_H1",":MV_GT_H2",
              ":DEV_LT_L",":DEV_GT_H",":PARAM8",":OLIMERR",":PARAM9"),
    "COMP-R":gen_pins(stop=9,mode='COMP-R_out'),
    "REG-RET":(":N",":F",":C",":A",":H")+gen_pins(start=61,stop=69),
    "MUX-I":(":AERR",":O"),
    "MUX-MN":(":AERR",":O"),
    "GENUSD-I":(":STATUS",),
    "GENUSD-O":(":RORD",":ORDM1",":ORDM2",":ORDM3",":ORDMAN",":ORDAUTO",":ORDBLK",
                ":ORDSTBY",":ORDC1",":ORDC2",":ORDC3",":ORDC4",":ORDC5",":ORDC6",":ORDC7",":ORDC8"),
    "MIN":(":A",":O"),
    "MAX":(":A",":O"),
    "REG":gen_pins(stop=35,mode="CONV-IB_out"),
    # FUNCM
    # PCPGM
	# MMC-IND
	# MMC-ORD
	# BTST
	# CE-MATR
	# SHIFT-L
	# SR-OA
	# EXP
	# LN
	# DP820-I
}

#=============================================================================
# --------------- Generate Excel report ---------------------------------------
try:
    import xlwt

    def GenXLSreport(code_before,code_after,line2line_status=False,excel_max=65530):
        '''
        generate XLS spreadsheet for file before vs file after
        '''

        fB = LoadABXFile(code_before)
        fA = LoadABXFile(code_after)
        if fB==None or fA==None:
            return

        xlsreport = xlwt.Workbook(encoding='ascii')

        addrstyle = xlwt.easyxf('pattern: pattern solid, fore_colour white;'
                                    'font: colour black, bold False;')
        diffstyle = xlwt.easyxf('pattern: pattern solid, fore_colour white;'
                                    'font: colour black, bold False, italic True;')
        headstyle = xlwt.easyxf('pattern: pattern solid, fore_colour yellow;'
                                    'font: colour black, bold True;')
        pinstyle = xlwt.easyxf('pattern: pattern solid, fore_colour white;'
                                    'font: colour blue, bold False;')
        newcodestyle=xlwt.easyxf('pattern: pattern solid, fore_colour white;'
                                    'font: colour blue, bold True;')
        removecodestyle=xlwt.easyxf('pattern: pattern solid, fore_colour white;'
                                    'font: colour red, bold True;')
        
        pinstyle.alignment.wrap=1
        addrstyle.alignment.horz=addrstyle.alignment.HORZ_LEFT
        pinstyle.alignment.horz=pinstyle.alignment.HORZ_LEFT
        diffstyle.alignment.horz=diffstyle.alignment.HORZ_CENTER
        headstyle.alignment.horz=headstyle.alignment.HORZ_CENTER

        cmppage = xlsreport.add_sheet(
            'LCT results', cell_overwrite_ok=False)
        
        if line2line_status:
            codepage_compare = xlsreport.add_sheet(
                'line-2-line', cell_overwrite_ok=False)

        stat_line = 1
        col_offs = 4
        addr_col = 0
        pins_col = 1
        name_col = 1
        pinv_col = 2
        extr_col = 2
        stat_col = 3
        desc_col = 0

        lcnt = 0
    # ------------------------- prepare -----------------------------------
        if line2line_status:
            codepage_compare.col(addr_col).width = 6000
            codepage_compare.col(pinv_col).width = 7500

            codepage_compare.col(stat_col).width = 3000

            codepage_compare.col(addr_col+col_offs).width = 6000
            codepage_compare.col(pinv_col+col_offs).width = 7500

            codepage_compare.col(addr_col+col_offs*2-1).width=6000 #message

            codepage_compare.col(addr_col+col_offs*2).width=6000 
            codepage_compare.col(pinv_col+col_offs*2).width=7500

            codepage_compare.write(lcnt, addr_col, 'Address', headstyle)  # 0
            codepage_compare.write(lcnt, pins_col, 'Pin', headstyle)  # 1
            codepage_compare.write(lcnt, pinv_col, 'Value', headstyle)  # 2
            codepage_compare.write(lcnt, stat_col, 'Status', headstyle)  # 3

            codepage_compare.write(lcnt, addr_col+col_offs,
                                    'Address', headstyle)  # 0
            codepage_compare.write(lcnt, pins_col+col_offs, 'Pin', headstyle)  # 1
            codepage_compare.write(lcnt, pinv_col+col_offs,
                                    'Value', headstyle)  # 2
    # -------------------------- compare -----------------------------------
        if line2line_status:
            lcnt = stat_line # lines counter
            for blk in fB.Blocks:  # check blocks in Before
                codepage_compare.write(
                        lcnt, addr_col, fB.GetBlock(blk).Address, addrstyle)
                codepage_compare.write(
                        lcnt, name_col, fB.GetBlock(blk).Name, addrstyle)
                codepage_compare.write(
                        lcnt, extr_col, fB.GetBlock(blk).Extra, addrstyle)
                    
                if blk in fA.Blocks: # if blk in After
                    codepage_compare.write(
                        lcnt, addr_col+col_offs, fA.GetBlock(blk).Address, addrstyle)
                    codepage_compare.write(
                        lcnt, name_col+col_offs, fA.GetBlock(blk).Name, addrstyle)
                    codepage_compare.write(
                        lcnt, extr_col+col_offs, fA.GetBlock(blk).Extra, addrstyle)
                    if fB.GetBlock(blk) != fA.GetBlock(blk): # blocks are not equal
                        codepage_compare.write(lcnt, stat_col, NEQ, diffstyle)
                else: # blk not in After
                    codepage_compare.write(
                        lcnt, addr_col+col_offs, fB.GetBlock(blk).Address, addrstyle)
                    codepage_compare.write(
                        lcnt, name_col+col_offs, fB.GetBlock(blk).Name, addrstyle)
                    codepage_compare.write(
                        lcnt, extr_col+col_offs, 'STATEMENT NOT FOUND',diffstyle)
                    codepage_compare.write(lcnt, stat_col, NEQ, diffstyle)
                lcnt += 1
                if lcnt>excel_max: break
                    #description line
                codepage_compare.write(lcnt, desc_col, fB.GetBlock(blk).Description)
                if blk in fA.Blocks: # check blk in After for Description 
                    codepage_compare.write(
                        lcnt, desc_col+col_offs, fA.GetBlock(blk).Description)
                lcnt += 1
                if lcnt>excel_max: break
                    # list PINs------------------------------------

                pins_before=fB.GetBlock(blk).GetPins()
                if blk in fA.Blocks:
                    pins=fA.GetBlock(blk).GetPins()
                if len(pins_before)>=len(pins): #get keys(pins) from bigger block
                    pins=pins_before

                for pin in pins:# iterate through the pins and compare
                    codepage_compare.write(lcnt, pins_col, pin)
                    codepage_compare.write(
                        lcnt, pinv_col, fB.GetBlock(blk).GetPin(pin),pinstyle)
                    # check pin  in After --------------------------------
                    if blk in fA.Blocks and pin in fA.GetBlock(blk).GetPins():
                        codepage_compare.write(lcnt, pins_col+col_offs, pin)
                        codepage_compare.write(
                            lcnt, pinv_col+col_offs, fA.GetBlock(blk).GetPin(pin),pinstyle)
                        if fA.GetBlock(blk).GetPin(pin) != fB.GetBlock(blk).GetPin(pin):
                            codepage_compare.write(lcnt, stat_col, NEQ, diffstyle)
                    # check pin not in After ---------------------------------
                    if blk in fA.Blocks and pin not in fA.GetBlock(blk).GetPins():
                        codepage_compare.write(lcnt, pins_col+col_offs, pin)
                        codepage_compare.write(
                            lcnt, pinv_col+col_offs, 'PIN NOT FOUND',diffstyle)
                        codepage_compare.write(lcnt, stat_col, NEQ, diffstyle)
                    lcnt += 1
                    if lcnt>excel_max: break
                lcnt += 2
                if lcnt>excel_max: break

            lcnt = stat_line
            for blk in fA.Blocks:  # check blocks in After
                if blk not in fB.Blocks:  # new block found
                    codepage_compare.write(
                        lcnt, addr_col+col_offs*2-1, 'NEW STATEMENT',diffstyle)
                    codepage_compare.write(
                        lcnt, addr_col+col_offs*2, fA.GetBlock(blk).Address,addrstyle)
                    codepage_compare.write(
                        lcnt, name_col+col_offs*2, fA.GetBlock(blk).Name,addrstyle)
                    codepage_compare.write(
                        lcnt, extr_col+col_offs*2, fA.GetBlock(blk).Extra,addrstyle)
                    lcnt += 1
                    if lcnt>excel_max: break
                    codepage_compare.write(
                        lcnt, desc_col+col_offs*2, fA.GetBlock(blk).Description)
                    lcnt += 1
                    if lcnt>excel_max: break
                    for pin in fA.GetBlock(blk).GetPins():
                        codepage_compare.write(lcnt, pins_col+col_offs*2, pin)
                        codepage_compare.write(
                            lcnt, pinv_col+col_offs*2, fA.GetBlock(blk).Pins[pin],pinstyle)
                        lcnt += 1
                        if lcnt>excel_max: break
                else:  # alignment with existing code
                    lcnt+=max(len(fA.GetBlock(blk).GetPins()),len(fB.GetBlock(blk).GetPins()))+4
                    if lcnt>excel_max: break
    # ========================== l2l report done =============================   

        report = fB.compare(fA) # simple text returned

        lcnt = stat_line
        wcnt = 0
        s = ''
        cmppage.col(0).width = 10000
        cmppage.col(1).width = 25000
        cmppage.col(2).width = 5000
        for l in report:
            style=addrstyle
            if RMVD in s:
                style=removecodestyle
                pass
            if NCD in s:
                style=newcodestyle
                pass
            if NEQ in s:
                style=diffstyle
            style.alignment.horz=style.alignment.HORZ_LEFT
            if l == '\n':
                cmppage.write(lcnt, wcnt, s,style)
                lcnt += 1
                if lcnt>excel_max: break
                wcnt = 0
                s = ''
            elif l == '\t':
                cmppage.write(lcnt, wcnt, s,style)
                wcnt += 1
                s = ''
            s += l
        if fB.difstat:
            xlsreport.save(code_after+'_DIF.xls') # diference found
        else:
            xlsreport.save(code_after+'.xls') # no dif detected

except:
    warnings.warn("xlwt must be installed!\nOtherwise GenXLSreport will not be accessible")
    pass